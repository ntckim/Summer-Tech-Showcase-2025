<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bellman-Ford Algorithm</title>
    <link rel="stylesheet" href="shared-styles.css">
</head>
<body>
    <h1>Bellman-Ford Algorithm</h1>
    
    <div class="section">
        <h2>Problem Description</h2>
        <p>
            Find the shortest path from a source vertex to all other vertices in a weighted graph, even with negative edge weights.
            The Bellman-Ford algorithm can also detect negative weight cycles.
        </p>
    </div>

    <div class="section">
        <h2>How Bellman-Ford Works</h2>
        <p>
            The algorithm relaxes all edges repeatedly. After V-1 iterations, it performs one more iteration to detect negative cycles.
            If any distance can still be improved, a negative cycle exists.
        </p>
    </div>

    <div class="section key-points">
        <h2>Key Characteristics</h2>
        <ul>
            <li><strong>Handles negative weights:</strong> Works with negative edge weights</li>
            <li><strong>Cycle detection:</strong> Can detect negative weight cycles</li>
            <li><strong>Dynamic programming:</strong> Uses optimal substructure property</li>
            <li><strong>Single-source:</strong> Finds shortest paths from one source</li>
        </ul>
    </div>

    <div class="section">
        <h2>Pseudocode</h2>
        <pre style="background-color: #f5f5f5; padding: 15px; border-radius: 5px; border: 1px solid #ddd;">
<strong>BellmanFord(graph, source):</strong>
    distance = new Array(size of graph)
    
    // Initialize distances
    for each vertex v in graph:
        distance[v] = INFINITY
    distance[source] = 0
    
    // Relax edges repeatedly
    for i = 1 to |V| - 1:
        for each edge (u, v) with weight w in graph:
            if distance[u] != INFINITY and distance[u] + w < distance[v]:
                distance[v] = distance[u] + w
    
    // Check for negative weight cycles
    for each edge (u, v) with weight w in graph:
        if distance[u] != INFINITY and distance[u] + w < distance[v]:
            return "Graph contains negative weight cycle"
    
    return distance
        </pre>
    </div>

    <div class="section complexity-table">
        <h2>Time & Space Complexity</h2>
        <ul>
            <li><strong>Time Complexity:</strong> O(VE) where V = vertices, E = edges</li>
            <li><strong>Space Complexity:</strong> O(V) for distance array</li>
        </ul>
    </div>
</body>
</html>
