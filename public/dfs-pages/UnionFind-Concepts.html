<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Union-Find Data Structure</title>
    <link rel="stylesheet" href="shared-styles.css">
</head>
<body>
    <h1>Union-Find Data Structure</h1>
    
    <div class="section">
        <h2>Problem Description</h2>
        <p>
            Efficiently track and merge disjoint sets of elements. Also known as Disjoint Set Union (DSU),
            it supports two main operations: finding which set an element belongs to and uniting two sets.
        </p>
    </div>

    <div class="section">
        <h2>How Union-Find Works</h2>
        <p>
            Union-Find maintains a forest of trees where each tree represents a set. It uses path compression
            during find operations and union by rank/size to keep trees balanced, achieving near-constant time complexity.
        </p>
    </div>

    <div class="section algorithm-steps">
        <h3>Key Operations:</h3>
        <ol>
            <li><strong>Find:</strong> Determine which set an element belongs to</li>
            <li><strong>Union:</strong> Merge two sets into one</li>
            <li><strong>Path Compression:</strong> Flatten tree during find operations</li>
            <li><strong>Union by Rank:</strong> Attach smaller tree under larger tree</li>
        </ol>
    </div>

    <div class="section key-points">
        <h2>Key Characteristics</h2>
        <ul>
            <li><strong>Disjoint sets:</strong> Manages separate, non-overlapping groups</li>
            <li><strong>Path compression:</strong> Optimizes find operations</li>
            <li><strong>Union by rank:</strong> Keeps trees balanced</li>
            <li><strong>Nearly constant time:</strong> Amortized O(α(n)) per operation</li>
        </ul>
    </div>

    <div class="section applications">
        <h2>Common Applications</h2>
        <ul>
            <li>Kruskal's algorithm for Minimum Spanning Tree</li>
            <li>Connected components in graphs</li>
            <li>Image processing and segmentation</li>
            <li>Network connectivity problems</li>
            <li>Least common ancestor problems</li>
        </ul>
    </div>

    <div class="section">
        <h2>Pseudocode</h2>
        <pre style="background-color: #f5f5f5; padding: 15px; border-radius: 5px; border: 1px solid #ddd;">
<strong>UnionFind(n):</strong>
    parent = new Array(n)
    rank = new Array(n)
    
    for i = 0 to n - 1:
        parent[i] = i    // Each element is its own parent initially
        rank[i] = 0      // Initial rank is 0

<strong>Find(x):</strong>
    if parent[x] != x:
        parent[x] = Find(parent[x])  // Path compression
    return parent[x]

<strong>Union(x, y):</strong>
    rootX = Find(x)
    rootY = Find(y)
    
    if rootX != rootY:
        // Union by rank
        if rank[rootX] < rank[rootY]:
            parent[rootX] = rootY
        else if rank[rootX] > rank[rootY]:
            parent[rootY] = rootX
        else:
            parent[rootY] = rootX
            rank[rootX]++

<strong>Connected(x, y):</strong>
    return Find(x) == Find(y)

<strong>UnionFind-WithSize(n):</strong>
    parent = new Array(n)
    size = new Array(n)
    
    for i = 0 to n - 1:
        parent[i] = i
        size[i] = 1

<strong>Union-BySize(x, y):</strong>
    rootX = Find(x)
    rootY = Find(y)
    
    if rootX != rootY:
        // Union by size (attach smaller tree under larger tree)
        if size[rootX] < size[rootY]:
            parent[rootX] = rootY
            size[rootY] += size[rootX]
        else:
            parent[rootY] = rootX
            size[rootX] += size[rootY]
        </pre>
    </div>

    <div class="section complexity-table">
        <h2>Time & Space Complexity</h2>
        <ul>
            <li><strong>Time Complexity:</strong> O(α(n)) amortized per operation</li>
            <li><strong>Space Complexity:</strong> O(n) for parent and rank arrays</li>
        </ul>
    </div>
</body>
</html>
