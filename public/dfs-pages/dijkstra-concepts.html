<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dijkstra's Algorithm</title>
    <link rel="stylesheet" href="shared-styles.css">
</head>
<body>
    <h1>Dijkstra's Algorithm</h1>
    
    <div class="section">
        <h2>Problem Description</h2>
        <p>
            Find the shortest path from a source vertex to all other vertices in a weighted graph with non-negative edge weights.
            Dijkstra's algorithm is a greedy algorithm that builds the shortest path tree incrementally.
        </p>
    </div>

    <div class="section">
        <h2>How Dijkstra's Works</h2>
        <p>
            The algorithm maintains a set of vertices whose shortest distance from the source is known. 
            It repeatedly selects the vertex with minimum distance and relaxes all its adjacent vertices.
        </p>
    </div>

    <div class="section key-points">
        <h2>Key Characteristics</h2>
        <ul>
            <li><strong>Greedy approach:</strong> Always chooses the locally optimal choice</li>
            <li><strong>Non-negative weights:</strong> Cannot handle negative edge weights</li>
            <li><strong>Single-source:</strong> Finds shortest paths from one source to all vertices</li>
            <li><strong>Optimal substructure:</strong> Optimal solution contains optimal sub-solutions</li>
        </ul>
    </div>

    <div class="section">
        <h2>Pseudocode</h2>
        <pre style="background-color: #f5f5f5; padding: 15px; border-radius: 5px; border: 1px solid #ddd;">
<strong>Dijkstra(graph, source):</strong>
    distance = new Array(size of graph)
    visited = new Set()
    priorityQueue = new MinHeap()
    
    // Initialize distances
    for each vertex v in graph:
        distance[v] = INFINITY
    distance[source] = 0
    
    priorityQueue.insert(source, 0)
    
    while priorityQueue is not empty:
        current = priorityQueue.extractMin()
        
        if current in visited:
            continue
        
        visited.add(current)
        
        for each neighbor of current:
            weight = graph[current][neighbor]
            newDistance = distance[current] + weight
            
            if newDistance < distance[neighbor]:
                distance[neighbor] = newDistance
                priorityQueue.insert(neighbor, newDistance)
    
    return distance
        </pre>
    </div>

    <div class="section complexity-table">
        <h2>Time & Space Complexity</h2>
        <ul>
            <li><strong>Time Complexity:</strong> O((V + E) log V) with binary heap</li>
            <li><strong>Space Complexity:</strong> O(V) for distance array and priority queue</li>
        </ul>
    </div>
</body>
</html>
