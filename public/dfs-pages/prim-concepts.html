<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Prim's Algorithm</title>
    <link rel="stylesheet" href="shared-styles.css">
</head>
<body>
    <h1>Prim's Algorithm (MST)</h1>
    
    <div class="section">
        <h2>Problem Description</h2>
        <p>
            Find the Minimum Spanning Tree (MST) of a connected, undirected graph. Prim's algorithm grows the MST
            one vertex at a time, always choosing the minimum weight edge from the current tree to a new vertex.
        </p>
    </div>

    <div class="section">
        <h2>How Prim's Works</h2>
        <p>
            The algorithm starts with any vertex and grows the MST by repeatedly adding the minimum weight edge
            that connects a vertex in the MST to a vertex outside the MST.
        </p>
    </div>

    <div class="section key-points">
        <h2>Key Characteristics</h2>
        <ul>
            <li><strong>Vertex-based:</strong> Grows MST one vertex at a time</li>
            <li><strong>Priority queue:</strong> Uses min-heap to find minimum edge</li>
            <li><strong>Greedy approach:</strong> Always selects minimum weight edge</li>
            <li><strong>Connected growth:</strong> MST remains connected at each step</li>
        </ul>
    </div>

    <div class="section">
        <h2>Pseudocode</h2>
        <pre style="background-color: #f5f5f5; padding: 15px; border-radius: 5px; border: 1px solid #ddd;">
<strong>Prim(graph, start):</strong>
    MST = empty set
    visited = new Set()
    priorityQueue = new MinHeap()
    totalWeight = 0
    
    // Start with the given vertex
    visited.add(start)
    
    // Add all edges from start vertex to priority queue
    for each edge (start, neighbor, weight) in graph[start]:
        priorityQueue.insert((weight, start, neighbor))
    
    while priorityQueue is not empty and visited.size() < |V|:
        (weight, u, v) = priorityQueue.extractMin()
        
        // If v is already in MST, skip this edge
        if v in visited:
            continue
        
        // Add edge to MST
        MST.add((u, v, weight))
        visited.add(v)
        totalWeight += weight
        
        // Add all edges from v to unvisited vertices
        for each edge (v, neighbor, edgeWeight) in graph[v]:
            if neighbor not in visited:
                priorityQueue.insert((edgeWeight, v, neighbor))
    
    return {MST, totalWeight}

<strong>PrimMatrix(graph, start):</strong>
    MST = empty set
    visited = new Array(|V|, false)
    key = new Array(|V|, INFINITY)  // Minimum edge weights
    parent = new Array(|V|, -1)     // Parent in MST
    
    key[start] = 0
    
    for i = 0 to |V| - 1:
        // Find vertex with minimum key value among unvisited vertices
        u = findMinKey(key, visited)
        visited[u] = true
        
        if parent[u] != -1:
            MST.add((parent[u], u, key[u]))
        
        // Update key values of adjacent vertices
        for v = 0 to |V| - 1:
            if graph[u][v] != 0 and not visited[v] and graph[u][v] < key[v]:
                key[v] = graph[u][v]
                parent[v] = u
    
    return MST
        </pre>
    </div>

    <div class="section complexity-table">
        <h2>Time & Space Complexity</h2>
        <ul>
            <li><strong>Time Complexity:</strong> O(E log V) with binary heap</li>
            <li><strong>Space Complexity:</strong> O(V) for priority queue and MST</li>
        </ul>
    </div>
</body>
</html>
